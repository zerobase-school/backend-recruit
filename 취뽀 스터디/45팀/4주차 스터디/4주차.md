# 45팀 취뽀스터디 4주차(2024.08.14 10:00~11:00)

--------------------------------------------------------------------
## 객체지향프로그래밍 - 안연정

🟩 컴퓨터 프로그램 = 명령어의 목록

🟩 여러 개의 독립된 단위, 즉 “객체” 들의 모임

🟩 각각의 객체는 메시지를 주고받고 데이터를 처리할 수 있음= 협력

🟩 프로그램을 유연하고 변경이 용이하게 만들 수 있음


🟩 다형성
--> 하나의 객체가 여러 가지 타입을 가질 수 있는것
    역할과 구현으로 세상을구분
–-> 역할: 인터페이스/ 구현: 인터페이스를구현한객체

🟩 다형성의본질

    • 인터페이스를구현한객체인스턴스를실행시점에
    유연하게변경가능

    • 다형성의본질을이해하려면, 협력이라는객체사이의
    관계에서시작해야한다.

    • 클라이언트를변경하지않고서버의구현기능을유연하게
    변경할수있다.


🟩 스프링과 객체 지향

    • 다형성이 가장 중요하다! -객체 지향의 꽃

    • 스프링은 다형성을 극대화해서 이용할 수 있도록 도와준다.

    • 스프링에서 이야기하는‘제어의역전(IoC), 의존관계주입(DI)은
    다형성을 활용해서 역할과 구현을 편리하게 다룰 수 있도록 지원한다. – 스프링 컨테이너는 다형성을 편리하게 사용하도록 지원하는 것이 전부

    • 스프링을 사용하면 마치 레고 블럭 조립하듯이, 공연 무대의 배우를
    선택하듯이, 구현을 편리하게 변경할 수 있다.


🟩 좋은 객체 지향 설계의 5가지 원칙(SOLID)

    🟩 SRP : 단일책임원칙(Single Responsibility Principle)
        --> 한 클래스는 하나의 책임만 가져야 한다.
        --> 중요한 판단의 기준은 변경이다. 
            변경이 있을 때 파급 효과가 적으면 단일 책임 원칙을 잘 따른것.

    🟩 OCP : 개방-책임원칙(Open/Closed Principle)
        --> 소프트 웨어 요소는 확장에는 열려있으나, 변경에는 닫혀있어야 한다.

    🟩LSP : 리스코프치환원칙(Liskov Substitution Principle)
        --> 자식 클래스는 부모 클래스와 동일 동작을 해야 재활용 가능성이 높다

    🟩 ISP : 인터페이스분리원칙(Interface Segregation Principle)
        --> 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스
        하나보다 낫다.

    🟩 DIP : 의존관계역전원칙(Dependency Inversion Principle)
        --> 구현 클래스에 의존하지말고, 인터페이스에 의존해야 한다
        --> 즉, 구현체에 의존하게 되면 변경이 아주 어려워 진다


🟩 SOLID 정리

    • 객체 지향의 핵심은다형성

    • 다형성만으로는 쉽게 부품을 갈아끼우듯이 개발할 수 없다.

    • 다형성만으로는 구현 객체를 변경할때 클라이언트 코드도 함께
      변경된다. – 클라이언트도변경해야, 부품을갈아낄수있다.

    • 다형성만으로는 OCP, DIP를 지킬 수 없다.


--------------------------------------------------------------------

## 재네릭(Generics) - 장현수

🟩 재네릭(Generics) 이란 ?
--> 제네릭(Generics)은 클래스나 메서드가 사용할 데이터 타입을 나중에, 즉 객체를 생성할 때나 메서드를 호출할 때 지정할 수 있게 해주는 기능입니다. 



🟩 재네릭(Generics) 은 왜 필요한가 ?
--> 코드의 재사용(같은 로직의 클래스를 다수 생성할 필요가 없다), 타입의 안정성을 위해 필요하다 


🟩 재네릭 사용 예시 ?
--> 
    ```
        public class PracticeGeneric<T>{ // --> <> 이 붙은 클래스를 제네릭 클래스라고 한다 마찬가지로 인터페이스에 붙으면 제네릭 인터페이스이다

        private T value;

        pubilc void set(T value){
            this.value = value;
        }

        public void get(){
            return value;
        }

        }
    
    ```


    🟩 제네릭 클래스는 String, Double 과 같이 미리 타입을 결정하지 않는다

    🟩 <T> --> T 를 타입 매개변수(Type Parameter) 라 지칭한다 이때의 T 는 반드시 래퍼 클래스로만 변할 수 있다

    🟩 PracticeGeneric<Integer> pg = new PracticeGeneric<>(); 
        --> 이때 Integer 는 타입인자(Type Argument)라고 한다 
   
    🟩 class PracticeGeneric<K,V>{...} 와 같이 여러 타입 매개변수가 사용가능하다  

    🟩 PracticeGeneric pg = new PracticeGeneric();
        --> 제네릭 클래스의 인스턴스를 이런 식으로 생성한다면
            이 인스턴스는 원시 타입(Object)가 사용된다 (권장 X)