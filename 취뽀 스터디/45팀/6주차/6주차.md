# 45팀 취뽀스터디 6주차(2024.08.28 10:00~11:00)

--------------------------------------------------------------------
## 의존 관계 자동 주입 - 안연정

🟩 Preview
 → DI 컨테이너란 자바의 객체를 생성하고 관리하고, 의존관계를 연결해주는 것 → 어플리케이션 안에 구현체가 들어갈 자리를 마련해놓으면, DI 컨테이너가 의존성을 주입함으로써, 해당 자리에 구현체를 넣어준다.



🟩 스프링 컨테이너를 사용하는 이유

    🟩 싱글톤 패턴 보장 
    --> 클래스의 인스턴스가 단 하나만 생성되도록 보장하는 디자인 패턴으로, 이 싱글톤 패턴을 사용하기 위한 코드 작성 불필요 및 자동적으로 관리됨

    🟩 자동 빈 등록
    --> 설정 파일은 필요하나 설정 정보는 불필요함
        다만, 설정 파일에 @Configuration, @ComponentScan 같은 어노테이션 필요 
        @ComponentScan은 자동으로 스프링 빈을 끌어올림(@Bean 대신에 @Component 메서드).

    🟩 자동 의존 관계 주입
    --> @Autowired 사용 --> 스프링 컨테이너에서 해당 빈들을 찾아서 자동 주입


🟩 수동 빈 등록은 언제 사용하면 좋을까?
    --> 스프링은 갈수록 자동을 선호하는 추세이고, 개발자 입장에서 스프링 빈을 하나 등록할 때, 
    @Component 만 넣어주면 끝나는 일을 @Configuration 설정 정보에 가서 @Bean 을 적고, 객체를
    생성하고, 주입할 대상을 일일이 적어주는 과정은 상당히 번거롭다.

🟩 업무 로직 빈
    비즈니스 업무 로직 관련 부분 : 컨트롤러, 서비스, 리포지토리 등 패턴이 있고, 문제가 발생 해도 어떤 곳에서 문제가 발생했는지 파악하기 쉬운 편
    → 자동 기능 사용


🟩 기술 지원 로직 빈
    데이터베이스 연결, 공통 로그처럼 업무 로직을 지원하는 하부 기술이나 공통 기술 : 업무 로직에 비해 수가 적고, 어플리케이션 전반에 영향을 미침. 적용이 잘되고 있는지조차 파악이 어려운 경우가 있기 때문
    → 가급적 수동으로 빈 등록
    어플리케이션의 구체적인 요구사항에 맞게 빈의 생성과 설정 제어
    디버깅과 테스트의 유연성 향상


🟩 조회 빈이 2개 이상일 때 문제와 해결 방법
    스프링 빈을 타입으로 조회하는데 같은 타입의 빈이 2개 이상이여서 의존관계 주입이 어려울 때, @Autowired 필드명 매칭, @Qualifier 매칭, @Primary 사용 등으로 해결할 수 있습니다. 

    @Autowired 필드명 매칭은 타입 매칭을 시도하고, 결과가 2개 이상일 때, 필드명, 파라미터명 순으로 매칭한다. 

    @Qualifier 매칭은 추가 구분자를 붙여줍니다. 
    자동관계를 주입할 때 @Qualifier 과 구분자를 입력하면, 해당 구분자를 가지고 있는 빈을 주입합니다. 

    @Primary는 같은 타입의 빈 중에 가장 우선권을 가지는 빈을 정하는 방법입니다.


🟩 수동 빈 등록을 언제 사용하는가?
    업무 로직의 경우에는 자동 빈 등록을 사용하는 게 좋습니다. 그렇지만 기술적인 문제나 공통 관심사를 처리할 때는 수동 빈 등록을 사용합니다. 데이터베이스 연결이나, 공통 로그 처리 같은 하부 기술이나 공통 처리는 어플리케이션 전반에 걸쳐 광범위한 영향을 미치기 때문에 어디서 어떻게 사용했는지 명확하게 드러내는 게 좋습니다
--------------------------------------------------------------------

## CORS, SOP - 윤영식

🟩 CORS(Cross-Origin Resource Sharing) 란 무엇인가?

--> CORS란 간단히 말해서 서로 다른 출처(Origin)를 가지는 클라이언트와 서버 간의 데이터 요청과 응답이 이루어지는 것을 말한다. 그렇다면 서로 다른 출처는 무엇을 뜻할까? 
도메인의 구조를 보았을 때 Protocl에서부터 Host 그리고 여기에 더해 포트 번호가 다르면 서로 다른 출처라고 간주한다.
즉, 서버의 위치를 찾아가기 위해 필요한 가장 기본적인 것들을 합쳐 놓은 것이다.



🟩 CORS를 왜 기본적으로 지원하지 않는 것일까?

--> 개발하다보면 프론트 측에서 CORS 이슈로 인해 외부 API를 요청하지 못한다거나 아니면 프론트와 백엔드 서버의 포트번호가 다른 경우 CORS 이슈가 발생하는 경우를 종종 볼 수있다. 이런 경우 보통 서버 측에서 응답 헤더에 Access-Controll-Allow-Origin이나
Access-Controll-Allow-Credentials 등의 내용을 추가하면 해결이 된다. 하지만 굳이 왜 이런 번거로운 과정을 거쳐서까지 CORS를 막는 걸까? 결론부터 말하면 보안 문제 때문이다. 이에 대해서는 SOP에 대한 배경지식이 필요하다.



🟩 SOP(Same-Origin Policy) 란 무엇인가?
--> SOP이란 웹 페이지가 동일한 origin을 가지는 서버에 대한 응답에 접근할 수 있는 정책을 의미한다. 
이러한 정책이 나온 이유는 한 출처가 다른 출처의 리소스에 접근하지 못하게 하기 위함이다. 
본 정책에 따라서 다른 악성 웹 사이트에서 악의적인 스크립트를 이용해 서버에 요청을 보내도 서버의 응답이 돌아와도 웹브라우저에 의해 차단되어 내용을 보진 못한다.
CORS란 이러한 SOP 정책에 대한 예외사항이라고 볼 수 있다


🟩 SOP의 보안적 허점과 이점

다만 유심히 봐야될 점은 SOP는 어디까지나 서버의 응답을 못 읽게 한다는 것이다.
이를테면 사용자가 현재 은행 사이트 A의 로그인 되어 있는 상태이고 그런 도중 어떠한 악성 사이트 B에 접근하게 되었다고 가정하자. 
이 때 모든 웹브라우저의 웹페이지는 요청 시 쿠키를 공유하기 때문에 B가 다른 웹 페이지의 쿠키에 접근을 하지 못하든 상관없이 B의 요청
이 A 사이트의 서버로 전달되어 쿠키에 담긴 세션이나 토큰을 통해 인증이 되어 B의 요청이 그대로 받아들여질 수 있다는 점이다.
이러면 B가 응답을 보진 못하겠지만 어쨌든 원하는 요청을 보내는 건 가능하다.
그래서 흔히 SOP 정책이 CSRF 공격을 방지하기 위해 나왔다는 말이 있지만 근본적으로
SOP는 브라우저 측에서 서버의 응답을 못 보게 할뿐이지 악의적인 요청을 방지하진 못한다.
그렇다면 SOP가 완전히 보안적으로 무용한가? 그렇진 않다. 적어도 다른 출처의 웹 페이지
가 보안에 활용되는 여러 정보들에 접근하는 것은 방지할 수 있다.

🟩 CSRF(Cross-Site Request Forgery)
    CSRF는 사용자가 인증한 세션에서 웹 애플리케이션이 정상적인 요청과 비정상적인 요청을 구분하지 못하는 점을 악용하는 공격 방식으로, 웹 애플리케이션이 사용자의 요청이 실제 사용자가 전송한 것인지 확인하지 않는 경우에 자주 발생합니다.

🟩 Access-Controll-Allow-Origin 란 무엇일까?
    Access-Control-Allow-Origin은 CORS에서 사용되는 HTTP 응답 헤더 중 하나로, 다른 도메인에서의 요청을 허용하는 경우 어떤 도메인에서 요청을 허용할 것인지를 명시합니다


--------------------------------------------------------------------

## JPA N+1 문제 - 장현수

🟩 JPA N+1 문제?
    조회 시 1개의 쿼리를 나올 줄 알고 설계 했는데 
    
    나오지 않아도 될 N개의 추가 쿼리가 발생하는 문제 
    
🟩 글로벌 패치 전략?
    EAGER 전략	- 부모 엔티티를 조회하면 자식 엔티티까지 전부 조회 한다
    LAZY 전략 - 자식 엔티티를 필요한 시점에 가져오는 방법
    --> 자식 엔티티 조회하면 N+1 문제 발생
    
🟩 지연 로딩 n+1 문제 해결책 ? 
    @Fetch Join을 사용 
            OR
    @EntityGraph를 활용
            OR
    @NamedEntityGraph를 활용
    
🟩 페이징 처리를 할때 경고가 생김
    경고가 생기는 이유는 
    쿼리 결과를 전부 메모리에 적재해서 페이징 처리를 하기 때문에 성능 상 치명적 이슈가 됨
    
🟩 페이징 처리를 할때 경고는 해결하는 방법
    @BatchSize (Batch성 loading이 발생--> 설정한 Batch Size 개의 쿼리문을 한번만 날림)사용
    @Fetch(FetchMode.SUBSELECT) 사용 
    
🟩 만약 둘이상의 컬렉션 조인할 때 문제 없음?
    MultiBagFetchException 발생

    Bag ? Hibernate에서 "Bag"은 순서가 없고 중복된 요소를 허용하는 컬렉션을 의미 

🟩 MultiBagFetchException 발생 해결책
    --> 자료형을 Set 으로 하자(하지만 얘도 페이징할 때 OOM)
    
🟩 페이징 처리문제 발생한다면? 
    @BatchSize 를 쓰자 